/* 
This file is part of JHAVE -- Java Hosted Algorithm Visualization
Environment, developed by Tom Naps, David Furcy (both of the
University of Wisconsin - Oshkosh), Myles McNally (Alma College), and
numerous other contributors who are listed at the http://jhave.org
site

JHAVE is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your
option) any later version.

JHAVE is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with the JHAVE. If not, see:
<http://www.gnu.org/licenses/>.
*/

/* Generated By:JavaCC: Do not edit this line. Parser.java */
package exe.memorymanager;

import exe.*;
import java.io.*;
import java.util.*;

public class Parser implements ParserConstants {
  public int numRows, numCols;
  public String language;
  public boolean drawgrid;
  public String listHead, listTail;
  public int listLength, count;
  public String listElements[];
  public double hSpacing;
  int indent;

  PrintWriter php;
  Formatter f;

  String dereferenceOp;  // "." or "->"
  String nullString;     // "null" or "NULL"
  String infoString;     // "info" or "data"
  int chainUnitLength;
  Operation ops[];
  int numOps;
  int lineNumber;  // as it will appear in the php script

  public Operation[] parseProgram(PrintWriter phpWriter)
        throws ParseException
  {

    ops = new Operation[ 100 ];
    numOps = 1;
    listElements = null;
    listTail = "";
    php = phpWriter;
    hSpacing = 0.5;
    indent = 1;
    infoString = "";

    System.out.print( "Parsing source code... " );
    System.out.flush();

    Input();

    System.out.println( "done" );

     return ops;
  }

  private void addOp( Operation op )
  {
     if (numOps == ops.length)
        throw new MemoryManagerException( "Source program is too long" );
     else
        ops[ numOps++ ] = op;
  }//addOp method

  private void phpWrite( PointerExpression expr )
  {
     if (expr.isNull())
         php.write( nullString );
     else
     {
         php.write( expr.getPointerName() );
         for(int i=0; i<expr.getChainLength(); i++)
            php.write( dereferenceOp +"next" );
     }
  }

  final public void Input() throws ParseException {
  Token t;
  Operation op = null;
      token_source.SwitchTo(IN_TITLE);
    titleLine();
    gridsizeLine();
      lineNumber = 1;
    if (jj_2_1(6)) {
      newlistLine();
    } else {
      ;
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NODE:
      case DELETE:
      case WHILE:
      case FOR:
      case BREAK:
      case IF:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      if (jj_2_2(3)) {
        op = pointerOperation();
      } else if (jj_2_3(3)) {
        op = layoutOperation();
      } else if (jj_2_4(3)) {
        op = controlOperation();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
         addOp( op );
    }
    jj_consume_token(0);
        php.write(",\n\"</font>\"");
  }

  final public void titleLine() throws ParseException {
  Token t;
    t = jj_consume_token(TITLE);
                php.write( "\"<b>&nbsp; "
                + t.image.substring(0,t.image.length()-1)  // drop final <EOL>
                + "</b><br>" );
  }

  final public void gridsizeLine() throws ParseException {
  Token t, f=null;
  Token r, c;
  Token l;
  Token h = null;
  Token d = null;
    jj_consume_token(COMMENT);
    jj_consume_token(GRIDSIZE);
    r = jj_consume_token(INT);
    c = jj_consume_token(INT);
    l = jj_consume_token(LANGUAGE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DRAWGRID:
      d = jj_consume_token(DRAWGRID);
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
    case REAL:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
        h = jj_consume_token(INT);
        break;
      case REAL:
        h = jj_consume_token(REAL);
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SMALLFONT:
      f = jj_consume_token(SMALLFONT);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    jj_consume_token(ENDOFCOMMENT);
     if (f!=null)
        php.write("<font size=\\\"-1\\\">\",\n");
     else
        php.write("<font size=\\\"-0\\\">\",\n");

     numRows = Integer.parseInt( r.image );
     numCols = Integer.parseInt( c.image );

     if (l.image.toUpperCase().equals("JAVA"))
     {
         language = "java";
         dereferenceOp = ".";
         chainUnitLength = 5; // length of ".next"
         nullString = "null";
     }
     else
     {
         language = "C++";
         dereferenceOp = "->";
         chainUnitLength = 6; // length of "->next"
         nullString = "NULL";
     }

     drawgrid = (d != null);

     if (h != null)
         hSpacing = Double.parseDouble( h.image );
  }

  final public void newlistLine() throws ParseException {
  Token s=null, h, l, t, c;
    jj_consume_token(NODE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STAR:
      s = jj_consume_token(STAR);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    h = jj_consume_token(IDENTIFIER);
    jj_consume_token(EQUAL);
    c = jj_consume_token(CREATELIST);
    jj_consume_token(LPAREN);
    l = jj_consume_token(CHARLIST);
    t = jj_consume_token(STRING);
    jj_consume_token(RPAREN);
    jj_consume_token(SEMICOLON);
     if ( (c.image.equals("Utils.createList")) && (language.equals("C++")) )
        {if (true) throw new MemoryManagerException( "\n\n" +
              "'createList' is a free function.");}

     if ( (c.image.equals("createList")) && (language.equals("java")) )
        {if (true) throw new MemoryManagerException( "\n\n" +
              "'createList' is a static function in the 'Utils' class");}

     listHead = h.image;
     listLength = 0;
     String list = l.image.replaceAll("\\s+","");
     listElements = new String[ list.length() / 4 ]; // 'X', repeated 

     for(int i=0; i<listElements.length; i++)
         listElements[i] = list.substring(4*i+1,4*i+2);
     listTail = t.image.substring(1, t.image.length()-1);

     // System.out.println(  t.image + " "  + t.image.replaceAll("\"","\\\"") );
      f = new Formatter();
      php.write("\"" + f.format("%2d",lineNumber).toString()
        +  "  Node " + ( language.equals("java") ? "" : "*" )
        + h.image + " = " +
        ( language.equals("java") ? "Utils." : "" )
        + "createList( "
        + list
        + "\\\"" + listTail + "\\\""
        + " );\"" );

      lineNumber++;
  }

  final public Operation pointerOperation() throws ParseException {
  Operation op;
    if (jj_2_5(3)) {
      op = pointerDeclaration();
    } else if (jj_2_6(3)) {
      op = pointerAssignment();
    } else if (jj_2_7(3)) {
      op = pointerDelete();
    } else if (jj_2_8(3)) {
      op = dataAssignment();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

  final public Operation pointerDeclaration() throws ParseException {
  Token  n=null, t=null, star=null, h;
  String pointer;
  AllocationExpression a=null;
  PointerExpression p = null;
  LayoutDirective ld = null;
    jj_consume_token(NODE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STAR:
      star = jj_consume_token(STAR);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    h = jj_consume_token(IDENTIFIER);
      if (lineNumber > 1)
          php.write( ",\n" );

      pointer = h.image;

      if ( star == null )   // no * (must be Java code)
      {
          if (language.equals( "C++" ))
             {if (true) throw new ParseException( "* is missing in front of the " +
                   "declaration of pointer variable '" + pointer + "'");}
      }
      else   // presence of * (must be C++ code)
      {
          if (language.equals( "java" ))
             {if (true) throw new ParseException( "* is not allowed in front of the " +
                   "declaration of pointer variable '" + pointer + "'");}
      }
      //System.out.println( "New declaration: ");
      //System.out.println( "    pointer variable: " + pointer );

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NULL:
        n = jj_consume_token(NULL);
        break;
      case IDENTIFIER:
        p = pointerExpression();
        break;
      case NEW:
        a = allocationExpression();
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMENT:
      ld = layoutDirective();
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
      Operation op;
      f = new Formatter();
      php.write(
                "\"" + f.format("%2d",lineNumber).toString()  );
      for(int i=0; i<indent; i++)
          php.write( "  " );
      php.write(
                "Node "
              + ( language.equals("java") ? "" : "*" )
              + pointer );

      int row = 0, col = 0;
      String ref ="", position="";

      if (ld != null)
      {
          if (ld.getType().equals("index"))
          {
             row = ld.getRow();
             col = ld.getCol();
             ref = ld.getRef();
             position = ld.getPosition();
          }
      }

      if (n != null)   // case: Node *<p> = NULL;
      {
           op = new OpDeclareAssign(
                   pointer,
                   new PointerExpression(),
                   row, col, ref, position );
           op.setLineNumber( lineNumber );

        //System.out.println( "in declare/NULL " + n.image );
          php.write( " = " + n.image );

      }
      else if (p != null)  // case Node *<p> = <pexpr>
      {
           op = new OpDeclareAssign(
                   pointer,
                   p,
                   row, col, ref, position );
           op.setLineNumber( lineNumber );

          php.write( " = " + p.getPointerName() );

          for(int i=0; i<p.getChainLength(); i++)
               php.write( dereferenceOp +"next" );

      }
      else if ( a != null )  // case: Node *<p> = new Node( ... );
      {

           op = new OpDeclareAllocateAssign(
                           pointer,
                           a,
                           row, col, ref, position );

           op.setLineNumber( lineNumber );

          if (a.getInfo() != null )
              php.write( " = new Node( '" + a.getInfo() + "' , ");
          else
          {
              php.write( " = new Node( " + a.getInfoPointer().getPointerName() );
              for(int i=0; i<a.getInfoPointer().getChainLength(); i++)
                   php.write( dereferenceOp + "next" );
              php.write( dereferenceOp + infoString + " , " );
          }
           phpWrite( a.getNext() );

           php.write( " )" );
      }
      else  // case: Node *<p>;
      {
           op = new OpDeclare( pointer, row, col, ref, position );
           op.setLineNumber( lineNumber );
      }

      php.write( ";\"" );
      lineNumber++;

      {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

  final public Operation pointerAssignment() throws ParseException {
   Token n=null;
   AllocationExpression a=null;
   PointerExpression LHS, RHS=null;
   LayoutDirective ld = null;
    LHS = pointerExpression();
    jj_consume_token(EQUAL);
     if (lineNumber>1)
        php.write( ",\n" );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      n = jj_consume_token(NULL);
      break;
    case IDENTIFIER:
      RHS = pointerExpression();
      break;
    case NEW:
      a = allocationExpression();
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(SEMICOLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMENT:
      ld = layoutDirective();
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
      Operation op;
      int row = 0, col = 0;
      String ref ="", position="";

      if (ld != null)
     {
          if (ld.getType().equals("index"))
          {
             row = ld.getRow();
             col = ld.getCol();
             ref = ld.getRef();
             position = ld.getPosition();
          }
      }


      f = new Formatter();
      php.write( "\"" + f.format("%2d",lineNumber).toString() );
      for(int i=0; i<indent; i++)
          php.write( "  " );

      php.write( LHS.getPointerName() );
      for(int i=0; i<LHS.getChainLength(); i++)
          php.write( dereferenceOp +"next" );

      php.write( " = " );

      if (RHS != null)  // <pexpr1> = <pexpr2>;
      {
          op = new OpAssign( LHS, RHS );
          php.write( RHS.getPointerName() );
          for(int i=0; i<RHS.getChainLength(); i++)
              php.write( dereferenceOp +"next" );
      }
      else if (n!=null)   // <pexpr> = NULL;
      {
          op = new OpAssign( LHS, new PointerExpression() );
          //System.out.println( "\n\n\nin assign/new " + n.image +"\n\n\n");
          php.write( n.image );
      }
      else  // <pexpr> = new Node( ... )
      {
          op = new OpAssignAllocate( LHS, a, row, col);

        //System.out.println( a.getInfo() + " " + a .getInfoPointer() );
          if (a.getInfo() != null )
              php.write( "new Node( '" + a.getInfo() + "' , ");
          else
          {
              php.write( "new Node( " + a.getInfoPointer().getPointerName() );
              for(int i=0; i<a.getInfoPointer().getChainLength(); i++)
                   php.write( dereferenceOp + "next" );
              php.write( dereferenceOp + infoString +" , " );
          }
          phpWrite( a.getNext() );

          php.write( " )" );

      }

      op.setLineNumber( lineNumber );

      lineNumber++;

      php.write( ";\"") ;

      {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

  final public Operation pointerDelete() throws ParseException {
  PointerExpression p;
    jj_consume_token(DELETE);
    p = pointerExpression();
    jj_consume_token(SEMICOLON);
      if (language.equals( "java" ))
        {if (true) throw new MemoryManagerException(
             "The 'delete' operator is not part of Java" );}

      if (lineNumber > 1)
          php.write( ",\n" );

      f = new Formatter();
      php.write(
                "\"" + f.format("%2d",lineNumber).toString()  );
      for(int i=0; i<indent; i++)
          php.write( "  " );
      php.write( "delete " + p.getPointerName() );
      for(int i=0; i<p.getChainLength(); i++)
        php.write( dereferenceOp +"next" );


      php.write( ";\"" );

      Operation op = new OpDelete( p );
      op.setLineNumber( lineNumber );

      lineNumber++;

      {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

  final public Operation dataAssignment() throws ParseException {
   Token charR=null;
   PointerExpression LHS, RHS=null;
    LHS = dataExpression();
    jj_consume_token(EQUAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      RHS = dataExpression();
      break;
    case CHAR:
      charR = jj_consume_token(CHAR);
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(SEMICOLON);
     if (lineNumber>1)
        php.write( ",\n" );

      Operation op = new OpDataAssign(
                        new DataExpression( LHS ),
                        ( charR != null ?
                          new DataExpression( charR.image.substring(1,2) ) :
                          new DataExpression( RHS ) ) );

      op.setLineNumber( lineNumber );

      f = new Formatter();
      php.write( "\"" + f.format("%2d",lineNumber).toString() );
      for(int i=0; i<indent; i++)
          php.write( "  " );

      php.write( LHS.getPointerName() );
      for(int i=0; i<LHS.getChainLength(); i++)
         php.write( dereferenceOp + "next" );
      php.write( dereferenceOp + infoString + " = " );

      if (charR != null)
         php.write( charR.image );
      else
      {
         php.write( RHS.getPointerName() );
         for(int i=0; i<RHS.getChainLength(); i++)
             php.write( dereferenceOp + "next" );
         php.write( dereferenceOp + infoString );
      }
      php.write( ";\"" );
      lineNumber++;

      {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

  final public Operation pointerAssignmentInForLoop() throws ParseException {
   Token n=null;
   AllocationExpression a=null;
   PointerExpression LHS, RHS=null;
   LayoutDirective ld = null;
    LHS = pointerExpression();
    jj_consume_token(EQUAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      n = jj_consume_token(NULL);
      break;
    case IDENTIFIER:
      RHS = pointerExpression();
      break;
    case NEW:
      a = allocationExpression();
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      Operation op;
      int row = 0, col = 0;
      String ref ="", position="";

      if (ld != null)
      {
          if (ld.getType().equals("index"))
          {
             row = ld.getRow();
             col = ld.getCol();
             ref = ld.getRef();
             position = ld.getPosition();
          }
      }

      String source = LHS.getPointerName();
      for(int i=0; i<LHS.getChainLength(); i++)
          source += dereferenceOp + "next";

      source += " = ";

      if (RHS != null)  // <pexpr1> = <pexpr2>;
      {
          op = new OpAssign( LHS, RHS );
          source += RHS.getPointerName();
          for(int i=0; i<RHS.getChainLength(); i++)
                source += dereferenceOp +"next";
      }
      else if (n!=null)   // <pexpr> = NULL;
      {
          op = new OpAssign( LHS, new PointerExpression() );
          //System.out.println( "\n\n\nin assign/new " + n.image +"\n\n\n");
          source += n.image;
      }
      else  // <pexpr> = new Node( ... )
      {
          op = new OpAssignAllocate(
                                  LHS,
                                  new AllocationExpression(
                                         a.getInfo(), a.getNext() ),
                                  row, col);

          if (a.getInfo() != null )
              php.write( "new Node( '" + a.getInfo() + "' , ");
          else
          {
              php.write( "new Node( " + a.getInfoPointer().getPointerName() );
              for(int i=0; i<a.getInfoPointer().getChainLength(); i++)
                   php.write( dereferenceOp + "next" );
              php.write( dereferenceOp + infoString + " , " );
          }

          source += a.getNext() + " )";
      }

      op.setLineNumber( lineNumber );
      ((OpAssign)op).setSource( source );

      php.write( source );

      {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

  final public PointerExpression pointerExpression() throws ParseException {
  Token p;
  Token c=null;
    p = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHAIN:
      c = jj_consume_token(CHAIN);
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
     if (c==null)
        {if (true) return new PointerExpression( p.image, 0 );}

     else
     {
        String chain = c.image.trim();

        if ((chain.indexOf("->")>-1) && (language.equals("java")))
           {if (true) throw new ParseException(
                  "operator '->' is not allowed in Java syntax" );}
        if ((chain.indexOf(".")>-1) && (language.equals("C++")))
           {if (true) throw new ParseException(
                  "operator '.' is not allowed in C++ syntax" );}

        String pointer = p.image;
        int chainLength = chain.length() / chainUnitLength;

        {if (true) return new PointerExpression( pointer, chainLength );}
     }
    throw new Error("Missing return statement in function");
  }

  final public AllocationExpression allocationExpression() throws ParseException {
  Token i=null;
  Token p1 = null;
  PointerExpression p2 =null, p=null;
    jj_consume_token(NEW);
    jj_consume_token(NODE);
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARLIST:
      i = jj_consume_token(CHARLIST);
      break;
    case IDENTIFIER:
      p = dataExpression();
      jj_consume_token(COMMA);
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      p1 = jj_consume_token(NULL);
      break;
    case IDENTIFIER:
      p2 = pointerExpression();
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RPAREN);
     Character info;

     if (i!=null)
     {
        if (i.image.replaceAll("\\s+","").trim().length() > 4)
           {if (true) throw new ParseException( "Node info must be a single character" );}

        info = i.image.charAt(1);

        if (p1!=null)
            {if (true) return new AllocationExpression(info, new PointerExpression());}
        else
            {if (true) return new AllocationExpression(info , p2);}
     }
     else
     {
       if (p1!=null)
            {if (true) return new AllocationExpression( p, new PointerExpression());}
        else
            {if (true) return new AllocationExpression( p, p2);}
     }
    throw new Error("Missing return statement in function");
  }

  final public Operation controlOperation() throws ParseException {
  Operation op;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHILE:
      op = whileLoop();
      break;
    case FOR:
      op = forLoop();
      break;
    case IF:
      op = ifStatement();
      break;
    case BREAK:
      op = breakStatement();
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

  final public Operation breakStatement() throws ParseException {
    jj_consume_token(BREAK);
    jj_consume_token(SEMICOLON);
     if (lineNumber>1)
        php.write( ",\n" );


       f = new Formatter();
       php.write( "\"" + f.format("%2d",lineNumber).toString() );
       int position = 2;
       for(int i=0; i<indent; i++)
       {
           php.write( "  " );
           position += 2;
       }
       php.write( "break;\"" );
      Operation op = new OpBreak();
      op.setLineNumber( lineNumber );
      lineNumber++;

      {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

  final public Operation whileLoop() throws ParseException {
 Operation op;
 Operation body[];
 BooleanExpression bexpr;
    jj_consume_token(WHILE);
    jj_consume_token(LPAREN);
     if (lineNumber>1)
        php.write( ",\n" );
    bexpr = booleanExpression();
    jj_consume_token(RPAREN);
       op = new OpWhile( bexpr );
       op.setLineNumber( lineNumber );

       f = new Formatter();
       php.write( "\"" + f.format("%2d",lineNumber).toString() );
       int position = 2;
       for(int i=0; i<indent; i++)
       {
           php.write( "  " );
           position += 2;
       }
       String boolExpr = bexpr.toString(dereferenceOp, nullString, infoString);
       if (bexpr instanceof CompoundBooleanExpression)
       {
         php.write( "while ( ( " + boolExpr + " ) ");
         php.write( ((CompoundBooleanExpression)bexpr).getConnector() +
                    "\",\n");
         bexpr.setStartHighlighting( position + 10);
         bexpr.setStopHighlighting( position + 10 + boolExpr.length() );
         lineNumber++;

         f = new Formatter();
         php.write("\"" + f.format("%2d",lineNumber).toString() );
         position = 2;
         for(int i=0; i<indent; i++)
         {
           php.write( "  " );
           position += 2;
         }
         String boolExpr2 =
             ((CompoundBooleanExpression)bexpr).getSecond().toString(
                                     dereferenceOp, nullString, infoString);
         php.write("        ( " + boolExpr2 + " ) )\"" );
         ((CompoundBooleanExpression)bexpr).getSecond().setStartHighlighting(
                                        position + 10 );
         ((CompoundBooleanExpression)bexpr).getSecond().setStopHighlighting(
                                        position + 10 + boolExpr2.length() );

       }
       else
       {
         php.write( "while ( " + boolExpr + " ) {\"");

         // character position for beginning/end of boolean expr
         bexpr.setStartHighlighting( position + 8);
         bexpr.setStopHighlighting( position + 8 + boolExpr.length() );

       }

       lineNumber++;
       indent++;
    body = block();
        if (body==null)
           {if (true) throw new MemoryManagerException(
                  "\nThe body of a WHILE loop cannot be empty.");}

        for( int i=0; i<body.length; i++)
          if (body[i] != null)
            ((OpWhile)op).addOperation( body[i] );


        php.write( ",\n" );

        indent--;
        f = new Formatter();
        php.write(
            "\"" + f.format("%2d",lineNumber).toString() );
        for(int i=0; i<indent; i++)
             php.write( "  " );
        php.write( "}\"");
        lineNumber++;



        {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

  final public Operation forLoop() throws ParseException {
  Operation op;
    op = forLoopPointer();
     {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

// for loop in which the loop variable is a pointer
  final public Operation forLoopPointer() throws ParseException {
 Operation op, init=null, inc=null;
 Operation body[];
 BooleanExpression bexpr;
 int position, saveStart=-1, saveStop=-1, saveStart2=-1, saveStop2=-1;
 int forLineNumber;
    jj_consume_token(FOR);
    jj_consume_token(LPAREN);
     if (lineNumber>1)
        php.write( ",\n" );

     f = new Formatter();
     php.write(  "\"" + f.format("%2d",lineNumber).toString() );
     position = 2;
     for(int i=0; i<indent; i++)
     {
         php.write( "  " );
         position += 2;
     }
     php.write( "for ( " );
     forLineNumber = lineNumber;
     position += 6;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      init = pointerAssignmentInForLoop();
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
      if (init!=null)
      {
         ( (OpAssign) init).setStartHighlighting( position );
         position += ((OpAssign)init).getSource().length();
         ( (OpAssign) init).setStopHighlighting( position );
         php.write( " ; " );
         position += 3;
      }
      else
      {
         php.write( "/* empty */ ; " );
         position += 14;
      }
    bexpr = booleanExpression();
    jj_consume_token(SEMICOLON);
       if (bexpr instanceof CompoundBooleanExpression)
       {
         php.write("\",\n");
         lineNumber++;

         f = new Formatter();
         php.write("\"" + f.format("%2d",lineNumber).toString() );
         position = 2;
         for(int i=0; i<indent; i++)
         {
           php.write( "  " );
           position += 2;
         }
         php.write( "      " ); // to account for "for ( "
         position += 6;

         String boolExpr = bexpr.toString(dereferenceOp, nullString,
                                          infoString);
         php.write( "( " + boolExpr + " ) ");
         php.write( ((CompoundBooleanExpression)bexpr).getConnector() +
                    "\",\n");

         bexpr.setStartHighlighting( position+ 2 );
         bexpr.setStopHighlighting( position+ 2 + boolExpr.length() );

         lineNumber++;

         f = new Formatter();
         php.write("\"" + f.format("%2d",lineNumber).toString() );
         position = 2;
         for(int i=0; i<indent; i++)
         {
           php.write( "  " );
           position += 2;
         }
         php.write( "      " ); // to account for "for ( "
         position += 6;
         String boolExpr2 =
             ((CompoundBooleanExpression)bexpr).getSecond().toString(
                                     dereferenceOp, nullString, infoString);
         php.write("( " + boolExpr2 + " ) ;\",\n" );
         lineNumber++;

         ((CompoundBooleanExpression)bexpr).getSecond().setStartHighlighting(
                                        position+ 2 );
         ((CompoundBooleanExpression)bexpr).getSecond().setStopHighlighting(
                                        position+ 2 + boolExpr2.length() );

        // to prepare for the increment section

         f = new Formatter();
         php.write("\"" + f.format("%2d",lineNumber).toString() );
         position = 2;
         for(int i=0; i<indent; i++)
         {
           php.write( "  " );
           position += 2;
         }
         php.write( "      " ); // to account for "for ( "
         position += 6;

       }
       else
       { // simple boolean expression

         bexpr.setStartHighlighting( position );

         String b = bexpr.toString( dereferenceOp, nullString, infoString);
         php.write( b );
         position += b.length();
         bexpr.setStopHighlighting( position );
         php.write( " ; " );
         position += 3;
       }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      inc = pointerAssignmentInForLoop();
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
       op = new OpForPointer( (OpAssign) init, bexpr, (OpAssign)inc );
       op.setLineNumber( forLineNumber );

       if ( inc != null )
       {
         ( (OpAssign) inc).setLineNumber( lineNumber );
         ( (OpAssign) inc).setStartHighlighting( position );
         ( (OpAssign) inc).setStopHighlighting(
                  position + ((OpAssign)inc).getSource().length() );
       }
       else
          php.write( "/* empty */" );

       php.write( " )\",\n");

       lineNumber++;

       f = new Formatter();
       php.write(
            "\"" + f.format("%2d",lineNumber).toString() );
       for(int i=0; i<indent; i++)
           php.write( "  " );
       php.write( "{\"");

       lineNumber++;
       indent++;
    body = block();
      if (body != null)
      {
        for( int i=0; i<body.length; i++)
          if (body[i] != null)
            ((OpForPointer)op).addOperation( body[i] );
      }
        php.write( ",\n" );

        indent--;
        f = new Formatter();
        php.write(
            "\"" + f.format("%2d",lineNumber).toString() );
        for(int i=0; i<indent; i++)
             php.write( "  " );
        php.write( "}\"");
        lineNumber++;



        {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

  final public Operation ifStatement() throws ParseException {
 Operation op;
 Operation thenB[] = null;
 Operation elseB[] = null;
 BooleanExpression bexpr;
    jj_consume_token(IF);
    jj_consume_token(LPAREN);
     if (lineNumber>1)
        php.write( ",\n" );
    bexpr = booleanExpression();
    jj_consume_token(RPAREN);
       op = new OpIf( bexpr );
       op.setLineNumber( lineNumber );


       f = new Formatter();
       php.write( "\"" + f.format("%2d",lineNumber).toString() );
       int position = 2;
       for(int i=0; i<indent; i++)
       {
           php.write( "  " );
           position += 2;
       }
       String boolExpr = bexpr.toString(dereferenceOp, nullString, infoString);
       if (bexpr instanceof CompoundBooleanExpression)
       {
         php.write( "if ( ( " + boolExpr + " ) ");
         php.write( ((CompoundBooleanExpression)bexpr).getConnector() +
                    "\",\n");
         bexpr.setStartHighlighting( position + 7);
         bexpr.setStopHighlighting( position + 7 + boolExpr.length() );
         lineNumber++;

         f = new Formatter();
         php.write("\"" + f.format("%2d",lineNumber).toString() );
         position = 2;
         for(int i=0; i<indent; i++)
         {
           php.write( "  " );
           position += 2;
         }
         String boolExpr2 =
             ((CompoundBooleanExpression)bexpr).getSecond().toString(
                                     dereferenceOp, nullString, infoString);
         php.write("     ( " + boolExpr2 + " ) )\"" );
         ((CompoundBooleanExpression)bexpr).getSecond().setStartHighlighting(
                                        position + 7 );
         ((CompoundBooleanExpression)bexpr).getSecond().setStopHighlighting(
                                        position + 7 + boolExpr2.length() );

       }
       else
       {
         php.write( "if ( " + boolExpr + " ) {\"");

         // character position for beginning/end of boolean expr
         bexpr.setStartHighlighting( position + 5);
         bexpr.setStopHighlighting( position + 5 + boolExpr.length() );

       }

       lineNumber++;
       indent++;
    thenB = block();
        ((OpIf)op).setThenBlock( thenB );

        php.write( ",\n" );

        indent--;

        f = new Formatter();
        php.write(
            "\"" + f.format("%2d",lineNumber).toString() );
        for(int i=0; i<indent; i++)
             php.write( "  " );
        php.write( "}");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
          php.write( " else {\"" );

          lineNumber++;
          indent++;
      elseB = block();
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
        if (elseB != null)
        {
           ((OpIf)op).setElseBlock( elseB );

           indent--;

           f = new Formatter();
           php.write(
              ",\n" +
              "\"" + f.format("%2d",lineNumber).toString() );
           for(int i=0; i<indent; i++)
               php.write( "  " );
           php.write( "}\"");

        }
        else
        {
           php.write( "\"");
        }
         lineNumber++;
        {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

  final public Operation[] block() throws ParseException {
  Operation ops[] = new Operation[100];
  Operation op = null;
  int count = 0;
    jj_consume_token(LBRACE);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NODE:
      case DELETE:
      case WHILE:
      case FOR:
      case BREAK:
      case IF:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_2;
      }
      if (jj_2_9(3)) {
        op = pointerOperation();
      } else if (jj_2_10(3)) {
        op = controlOperation();
      } else if (jj_2_11(3)) {
        op = layoutOperation();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
                if (count==100)
                   {if (true) throw new MemoryManagerException(
                      "While loop body contains 100+ operations");}
                ops[ count++ ] = op;
    }
    jj_consume_token(RBRACE);
       if (count==0)
          {if (true) return null;}
       else
          {if (true) return ops;}
    throw new Error("Missing return statement in function");
  }

  final public PointerExpression dataExpression() throws ParseException {
  PointerExpression p;
  Token i;
    p = pointerExpression();
    jj_consume_token(DEREFERENCEOP);
    i = jj_consume_token(INFO);
      if (infoString.equals( ""))  // first reference to 'info' field
         infoString = i.image;
      else
         if (! i.image.equals( infoString ))
             {if (true) throw new MemoryManagerException(
               "Wrong name for Node's data field: previously referred to as '"
               + infoString + "'" );}
      {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

  final public BooleanExpression booleanExpression() throws ParseException {
   Token c=null;
   BooleanExpression e1=null, e2=null;
   CompoundBooleanExpression e=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
    case CHAR:
    case IDENTIFIER:
      e1 = simpleBooleanExpression();
        {if (true) return e1;}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      e1 = simpleBooleanExpression();
      jj_consume_token(RPAREN);
      c = jj_consume_token(LOGICALCONNECTOR);
      jj_consume_token(LPAREN);
      e2 = simpleBooleanExpression();
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
       e = new CompoundBooleanExpression( e1, e2, c.image.equals("&&") );
       {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public BooleanExpression simpleBooleanExpression() throws ParseException {
  PointerExpression left=null, right=null;
  Token c, charL=null, charR=null;
    if (jj_2_12(3)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        left = pointerExpression();
        break;
      case NULL:
        jj_consume_token(NULL);
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      c = jj_consume_token(EQUALCOMPARATOR);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        right = pointerExpression();
        break;
      case NULL:
        jj_consume_token(NULL);
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
       {if (true) return new BooleanExpression(
                          "pointer",
                          ( left == null ? new PointerExpression() : left ),
                          ( right == null ? new PointerExpression() : right ),
                          c.image
                                   );}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHAR:
      case IDENTIFIER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          left = dataExpression();
          break;
        case CHAR:
          charL = jj_consume_token(CHAR);
          break;
        default:
          jj_la1[25] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUALCOMPARATOR:
          c = jj_consume_token(EQUALCOMPARATOR);
          break;
        case ORDERCOMPARATOR:
          c = jj_consume_token(ORDERCOMPARATOR);
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          right = dataExpression();
          break;
        case CHAR:
          charR = jj_consume_token(CHAR);
          break;
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
       {if (true) return new BooleanExpression(
                          "char",
                          ( left == null ?
                            new DataExpression( charL.image.substring(1,2) ) :
                            new DataExpression( left ) ),
                          ( right == null ?
                            new DataExpression( charR.image.substring(1,2) ) :
                            new DataExpression( right ) ),
                          c.image
                                   );}
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Operation layoutOperation() throws ParseException {
  Token h, d;
  String head;
    h = jj_consume_token(IDENTIFIER);
    d = jj_consume_token(DEREFERENCEOP);
    jj_consume_token(REDRAW);
    jj_consume_token(SEMICOLON);
      if (d.image.equals("->") && (language.equals("java")))
           {if (true) throw new ParseException(
                  "operator '->' is not allowed in Java syntax" );}
      if (d.image.equals(".") && (language.equals("C++")))
           {if (true) throw new ParseException(
                  "operator '.' is not allowed in C++ syntax" );}



     head = h.image;

     if (lineNumber > 1)
          php.write( ",\n" );

     Operation op = new OpLayout( "redraw", head );
     op.setLineNumber( lineNumber );


     f = new Formatter();
     php.write(
            "\"" + f.format("%2d",lineNumber).toString() );
     for(int i=0; i<indent; i++)
          php.write( "  " );
     php.write( head + dereferenceOp +
                "redrawListHorizontally();" + "\"");

     lineNumber++;

     {if (true) return op;}
    throw new Error("Missing return statement in function");
  }

  final public LayoutDirective layoutDirective() throws ParseException {
  Token r, ref=null, pos=ref, c;
    jj_consume_token(COMMENT);
    r = jj_consume_token(INT);
    c = jj_consume_token(INT);
    if (jj_2_14(6)) {
      ref = jj_consume_token(IDENTIFIER);
      if (jj_2_13(6)) {
        pos = jj_consume_token(IDENTIFIER);
      } else {
        ;
      }
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ENDOFCOMMENT:
      jj_consume_token(ENDOFCOMMENT);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return new LayoutDirective(
           "index",
           Integer.parseInt( r.image ),
           Integer.parseInt( c.image ),
           ( ref==null ? "" : ref.image ),
           ( pos==null ? "" : pos.image ) );}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  final private boolean jj_3R_19() {
    if (jj_3R_18()) return true;
    return false;
  }

  final private boolean jj_3R_12() {
    if (jj_3R_18()) return true;
    return false;
  }

  final private boolean jj_3R_20() {
    if (jj_3R_26()) return true;
    return false;
  }

  final private boolean jj_3R_11() {
    if (jj_3R_18()) return true;
    return false;
  }

  final private boolean jj_3_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_11()) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) return true;
    }
    if (jj_scan_token(EQUALCOMPARATOR)) return true;
    xsp = jj_scanpos;
    if (jj_3R_12()) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) return true;
    }
    return false;
  }

  final private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_12()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) return true;
    }
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_31()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_scan_token(NEW)) return true;
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_13()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_24() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_27()) return true;
    return false;
  }

  final private boolean jj_3R_3() {
    if (jj_scan_token(NODE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(20)) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(EQUAL)) return true;
    if (jj_scan_token(CREATELIST)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(CHARLIST)) return true;
    return false;
  }

  final private boolean jj_3R_8() {
    if (jj_3R_18()) return true;
    if (jj_scan_token(EQUAL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_9() {
    if (jj_scan_token(DELETE)) return true;
    if (jj_3R_18()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_3R_18()) return true;
    return false;
  }

  final private boolean jj_3R_23() {
    if (jj_3R_28()) return true;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_3R_6()) return true;
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_3R_32()) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_8()) return true;
    return false;
  }

  final private boolean jj_3R_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_29()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) return true;
    }
    return false;
  }

  final private boolean jj_3R_17() {
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_22() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_27()) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_3R_10()) return true;
    return false;
  }

  final private boolean jj_3R_15() {
    if (jj_3R_24()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_5()) return true;
    return false;
  }

  final private boolean jj_3R_18() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(48)) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_21() {
    if (jj_3R_18()) return true;
    if (jj_scan_token(DEREFERENCEOP)) return true;
    if (jj_scan_token(INFO)) return true;
    return false;
  }

  final private boolean jj_3R_14() {
    if (jj_3R_23()) return true;
    return false;
  }

  final private boolean jj_3R_7() {
    if (jj_scan_token(NODE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(20)) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    xsp = jj_scanpos;
    if (jj_3R_17()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3R_5() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(DEREFERENCEOP)) return true;
    if (jj_scan_token(REDRAW)) return true;
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_scan_token(BREAK)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_3R_5()) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_3R_4()) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_7()) return true;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_9()) return true;
    return false;
  }

  final private boolean jj_3R_16() {
    if (jj_3R_25()) return true;
    return false;
  }

  final private boolean jj_3R_13() {
    if (jj_3R_22()) return true;
    return false;
  }

  final private boolean jj_3R_4() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3_6()) {
    jj_scanpos = xsp;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3_8()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_6() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) {
    jj_scanpos = xsp;
    if (jj_3R_15()) {
    jj_scanpos = xsp;
    if (jj_3R_16()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_10() {
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_6()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_4()) return true;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) return true;
    }
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_3()) return true;
    return false;
  }

  public ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[30];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x28000000,0x8,0x0,0x0,0x200,0x100000,0x100000,0x90000000,0x200000,0x10,0x90000000,0x10,0x0,0x90000000,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x28000000,0x80010000,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x81,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x100f,0x0,0xc00,0xc00,0x0,0x0,0x0,0x1000,0x0,0x0,0x1000,0x0,0x1080,0x1000,0x10000,0x1100,0x1000,0xf,0x1000,0x1000,0x10,0x100f,0x1080,0x1000,0x1000,0x1080,0xc000,0x1080,0x1080,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[14];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  public Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Parser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[51];
    for (int i = 0; i < 51; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 30; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 51; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 14; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

   //phpWrite method

}
